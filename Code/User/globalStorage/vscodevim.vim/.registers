{"version":"1.0","registers":[["%",[{"text":"yihBluetWork/DrawEvent_v4.0.C","registerMode":0}]],["#",[{"text":"BluetAna/include/BluetDataModel.h","registerMode":0}]],["*",[{"registerMode":0,"text":"#include \"BluetMCPAnodeMaster.h\"\n#include \"BluetConfig.h\"\n#include \"cmath\"\n#include \"iostream\"\n#include <numeric> \n\nusing namespace std;\n\nBluetMCPAnodeMaster* BluetMCPAnodeMaster::fInstance = 0;\n\n//-----------------------------------------\n// BluetMCPAnodeMaster()\n//-----------------------------------------\nBluetMCPAnodeMaster::BluetMCPAnodeMaster()\n:DrawOpt(false),\nDir_Pic(\"\"),\ninittime(-100000),\nispark(-1),\nsizeX(1024),\nsizeY(2024),\n//timewindow(10.),\ntimewindow(2.),\nWaveLength(0),\nTimeStamp(0),\nncanvas(1)\n{\n    \n    // ----- set map -----\n    config = BluetConfig::GetInstance();\n\tconfig->ReadConfigFile();\n    Nboard = config->GetNboard(); // board == 4 preamp\n    Nchip = config->GetNchip();  //  chip == 2 ADM\n    Nchannel = config->GetNchannel(); // channel == 32 channel\n\n    sampleT = config->GetWaveformSamplingPeriod(); // [ns]\n    stampT = config->GetTimeStampPeriod(); //[ns]\n    TimeStampCutTrig0 = config->GetTimeStampCutTrig0();\n    WaveLength = config->GetWaveLength0();\n\n    // ----- set anode -----\n    NstripX = config->GetNstripX();\n    NstripY = config->GetNstripY();\n    Pitch = config->GetStripPitch();\n    double sidelengthx = Pitch*NstripX;\n    double sidelengthy = Pitch*NstripY;\n    \n/*     hanode0 = new TH2F(\"hanode0\", \"hanode0;Xstrip;Ystrip\", NstripX, 0, NstripX, NstripY, 0, NstripY);\n    hanode0->GetXaxis()->CenterTitle(); hanode0->GetYaxis()->CenterTitle(); */\n    hanode1 = new TH2F(\"hanode1\", \"hanode1;Xpos [mm];Ypos [mm]\", NstripX, 0., sidelengthx, NstripY, 0., sidelengthy);\n    hanode1->GetXaxis()->CenterTitle(); hanode1->GetYaxis()->CenterTitle();\n    ht0 = new TH1F(\"ht0\", \"ht0;time [point];count\", WaveLength*5, 0, WaveLength);\n    ht0->GetXaxis()->CenterTitle(); ht0->GetYaxis()->CenterTitle();\n    ht0tot = new TH1F(\"ht0tot\", \"hht0tott0;time [point];count\", WaveLength*5, 0, WaveLength);\n    ht0tot->GetXaxis()->CenterTitle(); ht0tot->GetYaxis()->CenterTitle();    \n    hanodex = new TH1F(\"hanodex\", \"hanodex;Xpos [mm];count\", NstripX, 0, NstripX*Pitch);\n    hanodex->GetXaxis()->CenterTitle(); hanodex->GetYaxis()->CenterTitle();\n    hanodey = new TH1F(\"hanodey\", \"hanodey;Ypos [mm];count\", NstripY, 0, NstripY*Pitch);\n    hanodey->GetXaxis()->CenterTitle(); hanodey->GetYaxis()->CenterTitle();\n        \n\n//    \n    fEvent = new BluetEvent();\n    fWavehit = new BluetWaveHit();    \n}\n\n//-----------------------------------------\n// SetCanvasSize()\n//-----------------------------------------\nvoid BluetMCPAnodeMaster::SetCanvasSize(int _sizeX, int _sizeY){\n  sizeX = _sizeX;\n  sizeY = _sizeY;\n}\n\n//-----------------------------------------\n// InitCanvas()\n//-----------------------------------------\nvoid BluetMCPAnodeMaster::InitCanvas(){\n\n  //TCanvas  \n    for (size_t i = 0; i < ncanvas; i++)\n    {\n        auto c = new TCanvas(Form(\"c%d\", i), Form(\"c%d\", i), sizeX, sizeY); //vec_canvas[0]->Divide(Ncol, Nrow);\n        vec_canvas.emplace_back(c);\n    }\n    canode = new TCanvas(\"canode\", \"canode\", sizeX, sizeX/2);\n    DrawOpt = true;\n\n    cout << \"NCanvas=\" << ncanvas  << endl;\n}\n\n//-----------------------------------------\n// print_map()\n//-----------------------------------------\nvoid BluetMCPAnodeMaster::print_map(){\n     std::cout << \"print_map\"<<endl;\n    // Iterate using C++17 facilities\n    for (const auto& [key, value] : map_channel_strip){\n        cout << '[' ; \n        std::cout  << \" => { \" << std::get<0>(key) << \", \"\n                                          << std::get<1>(key) << \", \"\n                                          << std::get<2>(key) << \" }\" ;\n        cout << \"] = \" << value << endl;\n    }\n    // // C++11 alternative:\n    //  for (const auto& n : m)\n    //      std::cout << n.first << \" = \" << n.second << \"; \";\n    //\n\n    std::cout << '\\n';\n}\n\n\n\n//-----------------------------------------\n// print_N()\n//-----------------------------------------\nvoid BluetMCPAnodeMaster::print_N(){\n    cout<<\"BluetMCPAnodeMaster::print_N()\"<<endl;    \n    cout<<Nchip << \"\\t\"  <<Nchannel << \"\\t\" <<Nboard<<endl;\n}\n\n//-----------------------------------------\n// map_to_strip()\n//-----------------------------------------\nint BluetMCPAnodeMaster::map_to_strip(int board, int chip, int channel){\n    std::tuple<int, int, int> channel_fullname = {board, chip, channel};\n    auto key = map_channel_strip.find(channel_fullname);\n    return key->second;\n}\n\n\n//-----------------------------------------\n// GetInstance()\n//-----------------------------------------\nBluetMCPAnodeMaster* BluetMCPAnodeMaster::GetInstance()\n{\n  if( fInstance == 0 ) fInstance = new BluetMCPAnodeMaster();\n  return fInstance;\n}\n\n//-----------------------------------------\n// SetWaveHit()\n//-----------------------------------------\nvoid BluetMCPAnodeMaster::SetWaveHit(BluetWaveHit* bwavehit){\n    fWavehit = bwavehit;\n    TimeStamp = bwavehit->TimeStamp;\n    if (fWavehit->TimeStamp<TimeStampCutTrig0)\n    {\n        WaveLength = config->GetWaveLength0();\n    }else\n    {\n        WaveLength = config->GetWaveLength();\n    }\n}\n\n//-----------------------------------------\n// HitCut()\n//-----------------------------------------\nbool BluetMCPAnodeMaster::HitCut(const array<double,6>& par){\n    bool cut0 = false;\n/*     if(par[0]>15)\n    cut0 = true; */\n    bool cut1 = false;\n    //if((par[0]>10. && par[0]<=3000. && par[2]>0.06 && par[2]<0.2) || (par[0]>3000. && par[2]>0.06 && par[2]<0.2) )\n    if((par[0]>15. && par[0]<=3000. && par[2]>0.06 && par[2]<0.4) || (par[0]>3000. && par[2]>0.06 && par[2]<0.4) )\n    cut0 = true;\n    if((par[0]>15. && par[0]<=3000. && par[5]/par[0]>0.08 && par[5]/par[0]<2.)||(par[0]>3000 && par[5]/par[0]>0.04 && par[5]/par[0]<1.5)) cut1 = true;\n    //if((par[0]>10. && par[0]<=3000. && par[5]/par[0]>0.6 && par[5]/par[0]<1.4) || (par[0]>3000 && par[5]/par[0]>0.3 && par[5]/par[0]<1.4))\n    //if((TimeStamp<=TimeStampCutTrig0 && par[5]/par[0]>0.3 && par[5]/par[0]<3) || (TimeStamp>TimeStampCutTrig0 && par[5]/par[0]>0.03 && par[5]/par[0]<3))\n     cut1 = true;\n    return (cut0 && cut1);\n/*     return cut0;  */    \n}\n\n//-----------------------------------------\n// HitCut()\n//-----------------------------------------\nbool BluetMCPAnodeMaster::HitCut(const BluetWavePara& par){\n    bool cut0 = false;\n    bool cut1 = false;\n    if((par.HitAmp>15. && par.HitAmp<=3000. && par.HitTau>0.06 && par.HitTau<0.4) || (par.HitAmp>3000. && par.HitTau>0.06 && par.HitTau<0.4) )\n    cut0 = true;\n/*     if((ppar.HitAmp>15. && par.HitAmp<=3000. && par[5]/par[0]>0.08 && par[5]/par[0]<2.)||(par[0]>3000 && par[5]/par[0]>0.04 && par[5]/par[0]<1.5)) \n    cut1 = true; */\n    cut1 = true;    \n    return (cut0 && cut1);\n}\n\n\n//-----------------------------------------\n// SetDrawHit()\n//-----------------------------------------\nvoid BluetMCPAnodeMaster::SetDrawHit(vector<int> *boardID, vector<int> *chipID, vector<int> *channelID, const vector<array<double,6>>& v_fitpar, bool drawOpt, bool printOpt)\n{\n    DrawOpt = drawOpt;  \n    ispark = 0;\n    // ----- reset ----- \n   \n    HitReset();\n\n    // ----- push hit ----- \n    for(int ihit=0; ihit<v_fitpar.size(); ++ihit){\n        auto fitpar = v_fitpar[ihit];\n        array<int,3> index{boardID->at(ihit), chipID->at(ihit), channelID->at(ihit)}; \n        HitProcess(index, fitpar);        \n    } // end of ihit loop\n\n    // ----- push Spark -----  \n    SparkProcess(printOpt);\n    // ----- fill event -----\n    if(!DrawOpt){\n        EndEvent();\n    }else{\n        canode->Update();\n    }\n}\n\n\n\n//-----------------------------------------\n// SetDrawHit2()\n//-----------------------------------------\nvoid BluetMCPAnodeMaster::SetDrawHit2(vector<int> *boardID, vector<int> *chipID, vector<int> *channelID, const vector<vector<array<double, 6>>>& fitpar, bool drawOpt, bool printOpt){\n    DrawOpt = drawOpt;\n\n    // ----- reset ----- \n    if(DrawOpt) {\n        canode->Clear();\n        canode->Divide(4, 4);   \n    }\n    multimap<double, st_data> map_fitpar{};\n\n    for (size_t i = 0; i < fitpar.size(); i++)\n    {\n        array<int,3> index{boardID->at(i), chipID->at(i), channelID->at(i)}; \n\n        for (auto content: fitpar[i])\n        {\n            st_data ss{};\n            ss.fitpar =  content;\n            ss.index = index;\n            auto t = content[1];\n            map_fitpar.emplace(t, ss);\n        }\n    }\n    bool flag{false};\n\n    for (const auto& ppara: map_fitpar)\n    {\n        auto tcurr = ppara.first;\n        auto index1 = ppara.second.index;\n        auto fitpar = ppara.second.fitpar;     \n\n        if (flag)\n        {\n            if (TMath::Abs(tcurr-inittime) <= timewindow)\n            {\n                HitProcess(index1, fitpar);\n            }else\n            {\n                SparkProcess(printOpt);\n                InitEvent(tcurr);\n                HitProcess(index1, fitpar);\n            }\n        }else\n        {\n            InitEvent(tcurr);\n            HitProcess(index1, fitpar);            \n            flag = true;\n        }\n    }\n\n/*     if (fEvent->Hits.size()>0)\n    {\n        SparkProcess(printOpt);\n    } */\n    \n\n    /*SparkProcess(printOpt);\n    if(!DrawOpt){\n        EndEvent();\n    }*/\n\n    // ----- draw ----- \n    if(DrawOpt){\n        canode->Update();\n    }\n\n}\n\n//-----------------------------------------\n// ReEvent()\n//-----------------------------------------\nvoid BluetMCPAnodeMaster::ReEvent(bool drawOpt, bool printOpt){\n    DrawOpt = drawOpt;\n    ispark = 0;\n\n    // ----- reset ----- \n    if(DrawOpt) {\n        for (const auto c : vec_canvas)\n        {\n            c->Clear(); \n            c->Divide(4,4);\n        }\n        canode->Clear();\n        ht0tot->Reset();\n    } \n/*     cout << ispark << \"\\t\" << \"test7\\n\" << endl;     */            \n\n    // ---- Divided by time ---- \n    bool flag{false};    \n    for (const auto& ppara: fWavehit->WavePara)\n    {\n        auto tcurr = ppara.HitT;\n        ht0tot->Fill(tcurr);\n        if (flag)\n        {\n            if (TMath::Abs(tcurr-inittime) <= timewindow)\n            {\n                HitProcess2(ppara);\n            }else\n            {\n/*                 cout << ispark << \"\\t\" << tcurr << endl;            */     \n                SparkProcess2(printOpt);\n                InitEvent2(tcurr);\n                HitProcess2(ppara);\n/*                 cout << ispark << \"\\t\" << tcurr <<\"\\n\" << endl;    */             \n            }\n        }else\n        {\n            InitEvent2(tcurr);\n            HitProcess2(ppara);         \n            flag = true;\n        }\n    }\n\n    if (HitParaX.size()>0&&HitParaY.size()>0)\n    {\n        SparkProcess2(printOpt);\n    }\n/*     cout << ispark << \"\\t\" << \"test7\\n\" << endl;        */         \n\n    // ----- draw ----- \n    if(DrawOpt){\n        canode->cd();\n        ht0tot->DrawCopy(\"\");\n        for (const auto c : vec_canvas)\n        {\n            c->Update(); \n        }\n        canode->Update();\n    }else\n    {\n        EndEvent();\n    }\n    \n}\n\n//-----------------------------------------\n// Drawpic()\n//-----------------------------------------\nint BluetMCPAnodeMaster::Drawpic(){\n    auto icanvas = (ispark-1)/8;\n    auto ipad = (ispark-1)%8;\n    if (icanvas>ncanvas-1)\n    {\n        return -1;\n    }\n    \n    vec_canvas[icanvas]->cd(ipad*2+1);\n    hanode1->DrawCopy(\"colz\");\n    vec_canvas[icanvas]->cd(ipad*2+2);\n    ht0->GetXaxis()->SetRange(max(ht0->FindFirstBinAbove() - 25,1), min(ht0->FindLastBinAbove() + 25, WaveLength*10)); \n    ht0->DrawCopy(\"\");    \n\n    return 1;\n}\n\n//-----------------------------------------\n// EndEvent()\n//-----------------------------------------\nvoid BluetMCPAnodeMaster::EndEvent(){\n    fEvent->EventCount = fWavehit->EventCount;\n    fEvent->TimeStamp = fWavehit->TimeStamp;\n    eventTree->Fill();\n    fEvent->Reset();\n}\n\n//-----------------------------------------\n// HitReset()\n//-----------------------------------------     \nvoid BluetMCPAnodeMaster::HitReset(){\n    // ----- reset ----- \n    ht0->Reset();   \n    HitposX.clear();\n    HitposY.clear();\n    HittimeX.clear();\n    HittimeY.clear();\n    HitampX.clear();\n    HitampY.clear();\n    fEvent->Reset();\n}\n\n//-----------------------------------------\n// HitReset2()\n//-----------------------------------------     \nvoid BluetMCPAnodeMaster::HitReset2(){\n    // ----- reset ----- \n    HitParaX.clear();\n    HitParaY.clear();    \n}\n\n//-----------------------------------------\n// InitEvent()\n//-----------------------------------------\nvoid BluetMCPAnodeMaster::InitEvent(double tcurr){\n    HitReset();       \n    inittime = tcurr;\n}\n\n//-----------------------------------------\n// InitEvent2()\n//-----------------------------------------\nvoid BluetMCPAnodeMaster::InitEvent2(double tcurr){\n    // ----- reset ----- \n    HitReset2();   \n    inittime = tcurr;    \n}\n\n\n//-----------------------------------------\n// HitProcess()\n//-----------------------------------------\nvoid BluetMCPAnodeMaster::HitProcess(const array<int, 3>& index, const array<double, 6>& fitpar){\n\n        auto stripID = map_to_strip(index[0], index[1], index[2]);\n        BluetHit fHit{};\n        if(stripID<NstripX) {\n            if(HitCut(fitpar)){\n                HitposX.emplace_back((stripID+0.5)*Pitch);\n                HitampX.emplace_back(fitpar[0]);\n                HittimeX.emplace_back(fitpar[1]);\n            }\n            fHit.HitAmp = fitpar[0];\n            fHit.HitT = fitpar[1];\n            fHit.HitTau = fitpar[2];\n            fHit.HitBaseline = fitpar[3];\n            fHit.HitChi2 = fitpar[4];\n            fHit.HitPeakVal = fitpar[5];\n            fHit.HitPos = (stripID+0.5)*Pitch;\n            fHit.HitBoardID = index[0]; \n            fHit.HitChipID = index[1]; \n            fHit.HitChannelID = index[2]; \n            if(DrawOpt){\n                cout<<\"Xstrip >>> DAQ-ID: \"<<fHit.HitBoardID<<\"-\"<<fHit.HitChipID<<\"-\"<<fHit.HitChannelID\n                            <<\", stripID = \"<<stripID<<\", xpos = \"<<(stripID+0.5)*Pitch<<endl;\n                for(int ibin=0; ibin<NstripY; ibin++) {\n                    hanode1->Fill((stripID+0.5)*Pitch, (ibin+0.5)*Pitch, fitpar[0]); \n                }          \n            }\n                ht0->Fill(fitpar[1]);                \n        }\n        \n        if(stripID>=NstripX) {\n            if(HitCut(fitpar)){\n                HitposY.emplace_back((stripID-NstripX+0.5)*Pitch);\n                HitampY.emplace_back(fitpar[0]);\n                HittimeY.emplace_back(fitpar[1]);\n            }\n            fHit.HitAmp = fitpar[0];\n            fHit.HitT = fitpar[1];\n            fHit.HitTau = fitpar[2];\n            fHit.HitBaseline = fitpar[3];\n            fHit.HitChi2 = fitpar[4];\n            fHit.HitPeakVal = fitpar[5];\n            fHit.HitPos = (stripID+0.5)*Pitch;\n            fHit.HitTypeName = \"StripY\";\n            fHit.HitBoardID = index[0]; \n            fHit.HitChipID = index[1]; \n            fHit.HitChannelID = index[2]; \n            if(DrawOpt){\n                cout<<\"Ystrip >>> DAQ-ID: \"<<fHit.HitBoardID<<\"-\"<<fHit.HitChipID<<\"-\"<<fHit.HitChannelID\n                <<\", stripID = \"<<stripID<<\", ypos = \"<<(stripID-NstripX+0.5)*Pitch<<endl;\n                for(int ibin=0; ibin<NstripX; ibin++) {\n/*                     hanode0->Fill(ibin, stripID-NstripX, fitpar[0]); */\n                    hanode1->Fill((ibin+0.5)*Pitch, (stripID-NstripX+0.5)*Pitch, fitpar[0]);    \n                }\n            }\n                ht0->Fill(fitpar[1]);\n        }\n/*         fEvent->Hits.emplace_back(fHit); */\n\n}\n\n//-----------------------------------------\n// HitProcess2()\n//-----------------------------------------\n\nvoid BluetMCPAnodeMaster::HitProcess2(const BluetWavePara& par){\n    \n    if(HitCut(par) == false) return;\n    auto stripID = par.HitStripID;\n    wavepara_data w_d{};\n    if(stripID<NstripX) {\n        w_d.HitPos = (stripID+0.5)*Pitch;\n        w_d.HitAmp = par.HitAmp;\n        w_d.HitTime = par.HitTime;\n        w_d.HitT = par.HitT;\n        HitParaX.emplace_back(w_d);\n    }\n\n    if(stripID>=NstripX) {\n        w_d.HitPos = (stripID-NstripX+0.5)*Pitch;\n        w_d.HitAmp = par.HitAmp;\n        w_d.HitTime = par.HitTime;\n        w_d.HitT = par.HitT;        \n        HitParaY.emplace_back(w_d);\n    }\n\n}\n\n//-----------------------------------------\n// SparkProcess()\n//-----------------------------------------\nint BluetMCPAnodeMaster::SparkProcess(bool printOpt){\n   \n    if( HitposX.size()==0 || HitposY.size()==0 ) \n    return -1;\n    ispark++;\n    if (DrawOpt)\n    {\n        Drawpic();\n    }\n \n    BluetSpark fSpark;\n    fSpark.Nhits = HitposX.size() + HitposY.size();\n    fSpark.NhitsX = HitposX.size();\n    fSpark.NhitsY = HitposY.size();\n    fSpark.TminX = *min_element(HittimeX.begin(), HittimeX.end());\n    fSpark.TminY = *min_element(HittimeY.begin(), HittimeY.end());\n    fSpark.TmaxX = *max_element(HittimeX.begin(), HittimeX.end());\n    fSpark.TmaxY = *max_element(HittimeY.begin(), HittimeY.end());\n    auto minT = min(fSpark.TminX, fSpark.TminY);\n    fSpark.TOF0 = (double)TimeStamp*stampT - (double)WaveLength*sampleT + minT*sampleT;\n    \n    double sumEx = 0.;\n    double weightx = 0.;\n    //double posx = 0.;\n    for(int ix=0; ix<HitposX.size(); ++ix){\n        weightx = weightx + HitposX[ix]*HitampX[ix];\n        //posx = posx + HitposX[ix];\n        sumEx = sumEx + HitampX[ix];\n    }\n    \n    double sumEy = 0.;\n    double weighty = 0.;\n    //double posy = 0.;\n    for(int iy=0; iy<HitposY.size(); ++iy){\n        weighty = weighty + HitposY[iy]*HitampY[iy];\n        //posy = posy + HitposY[iy];\n        sumEy = sumEy + HitampY[iy];\n    }\n\n    if( sumEx!=0. && sumEy!=0.){\n        fSpark.CentroidPos[0] = weightx/sumEx;\n        fSpark.CentroidPos[1] = weighty/sumEy;\n    }\n    \n    fSpark.SparkSumE = sumEx + sumEy;\n    fSpark.SigmaT = ht0->GetStdDev();\n    fEvent->Sparks.emplace_back(fSpark);\n    if(printOpt){\n        cout<<\"\\nCentroidPos:  x = \"<<fSpark.CentroidPos[0]<<\" y = \"<<fSpark.CentroidPos[1]<<endl;\n        cout<<\"SparkSumE = \"<<fSpark.SparkSumE<<endl;\n        cout<<\"SigmaT = \"<<ht0->GetStdDev()<<endl;\n    }\n\n    if (DrawOpt)\n    {\n        hanode1->Reset();   \n        ht0->Reset();  \n    }\n    \n    return 1;\n\n}\n\n\nint BluetMCPAnodeMaster::SparkProcess2(bool printOpt){\n\n    if( HitParaX.size()==0 || HitParaY.size()==0 ) \n    return -1;\n\n    //sort by StripID/HitPos\n    sort(HitParaX.begin(), HitParaX.end(), comparewavedata);\n    sort(HitParaY.begin(), HitParaY.end(), comparewavedata);\n    \n    //Divide by StripID/HitPos\n    vector<vector<wavepara_data>> gHitParaX;\n    vector<vector<wavepara_data>> gHitParaY;\n    auto Pitch_ = Pitch;\n    auto divide_space = [Pitch_](vector<vector<wavepara_data>>& gHitPara, vector<wavepara_data>& HitPara){\n        vector<wavepara_data> tempHitPara;\n        tempHitPara.emplace_back(HitPara[0]);\n        for (size_t i = 0; i < HitPara.size() - 1; i++)\n        {\n            auto df = abs(HitPara[i+1].HitPos - HitPara[i].HitPos);\n            if (df <= 2*Pitch_)\n            {\n                tempHitPara.emplace_back(HitPara[i+1]);\n            }else\n            {\n                gHitPara.emplace_back(tempHitPara);\n                tempHitPara.clear();\n                tempHitPara.emplace_back(HitPara[i+1]);\n            }\n        }\n        if (!tempHitPara.empty()) {\n            gHitPara.emplace_back(tempHitPara);\n        }\n    };\n\n    divide_space(gHitParaX, HitParaX);\n    divide_space(gHitParaY, HitParaY);   \n\n\n    // rebuild by Goodness\n    auto nxevent = gHitParaX.size();\n    auto nyevent = gHitParaY.size();\n    auto nevent = min(nxevent, nyevent);\n    \n\n    vector<vector<double>> vGoodness(nxevent, vector<double>(nyevent));\n\n    for (size_t i = 0; i < gHitParaX.size(); i++)\n    {\n        for (size_t j = 0; j < gHitParaY.size(); j++)\n        {\n            vGoodness[i][j] = calculateGoodness(gHitParaX[i], gHitParaY[j]);\n        }\n    }\n\n    vector<std::array<int,2>> vMatchId{};\n    for (int ievent = 0; ievent < nevent; ievent++)\n    {\n        double minGoodness = std::numeric_limits<double>::max();\n        int minRow = 0, minCol = 0;            \n        for (int i = 0; i < nxevent; ++i) {\n            for (int j = 0; j < nyevent; ++j) {\n                if (vGoodness[i][j] < minGoodness) {\n                    minGoodness = vGoodness[i][j];\n                    minRow = i; \n                    minCol = j; \n                }\n            }\n        }\n        std::array<int,2> gid = {minRow,minCol};\n        vMatchId.emplace_back(gid);\n        // minrow and mincol set as max\n        for (size_t j = 0; j < nyevent; ++j) {\n            vGoodness[minRow][j] = std::numeric_limits<double>::max();\n        }\n\n        for (size_t i = 0; i < nxevent; ++i) {\n            vGoodness[i][minCol] = std::numeric_limits<double>::max();\n        }            \n    }\n\n    for (const auto & id: vMatchId)\n    {\n        ispark++;\n        BluetSpark fSpark;\n        \n        fSpark.NhitsX = gHitParaX[id[0]].size();\n        fSpark.NhitsY = gHitParaY[id[1]].size();    \n//        std::cout << gHitParaX[id[0]].size() << \"\\t\" << gHitParaY[id[1]].size()  << \"\\t\" << vMatchId.size()<< endl;\n        fSpark.Nhits = fSpark.NhitsX + fSpark.NhitsY;\n        fSpark.TminX = std::numeric_limits<double>::max();\n        fSpark.TmaxX = 0;  \n        fSpark.TminY = std::numeric_limits<double>::max();\n        fSpark.TmaxY = 0;\n        double sumEx = 0.;\n        double sumEy = 0.;\n        double weightx = 0.;\n        double weighty = 0.;\n        \n        for (const auto & temppara: gHitParaX[id[0]])\n        {\n            if (temppara.HitT < fSpark.TminX){\n                fSpark.TminX = temppara.HitT;\n            }\n            if (temppara.HitT > fSpark.TmaxX)\n            {\n                fSpark.TmaxX = temppara.HitT;\n            }\n            weightx = weightx + temppara.HitAmp*temppara.HitPos;\n            sumEx = sumEx + temppara.HitAmp;\n            hanodex->Fill(temppara.HitPos, temppara.HitAmp);\n            ht0->Fill(temppara.HitT);\n            \n            if (DrawOpt)\n            {\n                cout << \"Xstrip >>> xpos = \" << temppara.HitPos << endl;\n                for(int ibin=0; ibin<NstripX; ibin++) {\n                    hanode1->Fill(temppara.HitPos, (ibin+0.5)*Pitch, temppara.HitAmp); \n                }  \n            }\n        }\n        \n        for (const auto & temppara: gHitParaY[id[1]])\n        {\n            if (temppara.HitT < fSpark.TminY){\n                fSpark.TminY = temppara.HitT;\n            }\n            if (temppara.HitT > fSpark.TmaxY)\n            {\n                fSpark.TmaxY = temppara.HitT;\n            }\n            weighty = weighty + temppara.HitAmp*temppara.HitPos;\n            sumEy = sumEy + temppara.HitAmp;\n            hanodey->Fill(temppara.HitPos, temppara.HitAmp);\n            ht0->Fill(temppara.HitT);     \n            if (DrawOpt)\n            {\n                cout << \"Ystrip >>> ypos = \" << temppara.HitPos << endl;\n                for(int ibin=0; ibin<NstripY; ibin++) {\n                    hanode1->Fill((ibin+0.5)*Pitch, temppara.HitPos, temppara.HitAmp); \n                }  \n            }     \n        }\n        fSpark.CentroidPos[0] = weightx/sumEx;\n        fSpark.CentroidPos[1] = weighty/sumEy;\n\n        fSpark.SparkSumE = sumEx + sumEy;\n        fSpark.SigmaT = ht0->GetStdDev();\n        fSpark.SigmaX = hanodex->GetStdDev();\n        fSpark.SigmaY = hanodey->GetStdDev();\n        auto minT = min(fSpark.TminX, fSpark.TminY);\n        fSpark.TOF0 = (double)TimeStamp*stampT - (double)WaveLength*sampleT + minT*sampleT;\n\n        fEvent->Sparks.emplace_back(fSpark);\n        if(printOpt){\n            cout<<\"\\nCentroidPos:  x = \"<<fSpark.CentroidPos[0]<<\" y = \"<<fSpark.CentroidPos[1]<<endl;\n            cout<<\"SparkSumE = \"<<fSpark.SparkSumE<<endl;\n            cout<<\"T = \"<<minT<<endl;\n            cout<<\"<<<<<<<<<<<<<<<<<<<<<\"<<endl;\n/*             cout << Form(\"WaveLength = %d, TimeStamp = %d, sampleT = %f\", WaveLength, TimeStamp, sampleT) << endl;\n */        }\n\n    \n        if (DrawOpt)\n        {        \n            Drawpic();    \n            hanode1->Reset();   \n        }\n        hanodex->Reset();\n        hanodey->Reset();   \n        ht0->Reset();            \n    }\n    return 1;\n\n}\n\nvoid BluetMCPAnodeMaster::OutputPicture(){\n  if (Dir_Pic!=\"\")\n  {\n    for (size_t i = 0; i < ncanvas; i++)\n    {\n        vec_canvas[i]->SaveAs(Form(\"%s/c%d.png\", Dir_Pic.data(), i));\n    }\n    canode->SaveAs(Form(\"%s/Anode.png\", Dir_Pic.data()));\n  }else{\n    cout << \"Dir of picture was not found!!\" << endl; \n  }    \n}\n\n//-----------------------------------------\n// CompareWavedata()\n//-----------------------------------------\nbool BluetMCPAnodeMaster::comparewavedata(const wavepara_data& a, const wavepara_data& b){\n    return a.HitPos < b.HitPos;\n}\n\n//-----------------------------------------\n// calculateGoodness()\n//-----------------------------------------\ndouble BluetMCPAnodeMaster::calculateGoodness(const vector<wavepara_data>& vx, const vector<wavepara_data>& vy) {\n    array<double ,2> nhit = {vx.size(), vy.size()};\n    array<double ,2> sumAmp;\n    array<double ,2> sumT;\n    array<double ,2> avgt;\n    //array<double ,2> stddet;    \n    for (size_t i = 0; i < nhit[0]; i++)\n    {\n        sumAmp[0] = vx[i].HitAmp;\n        sumT[0] = vx[i].HitT;\n    }\n\n    for (size_t i = 0; i < nhit[1]; i++)\n    {\n        sumAmp[1] = vy[i].HitAmp;\n        sumT[1] = vy[i].HitT;\n    }  \n\n    for (size_t i = 0; i < 2; i++)\n    {\n        avgt[i] = sumT[i]/nhit[i];\n    }\n      \n    auto Goodness = (nhit[0]-nhit[1])*(nhit[0]-nhit[1]) + 0.5*(sumAmp[0] - sumAmp[1])*(sumAmp[0] - sumAmp[1]) + 0.2*(avgt[0] - avgt[1])*(avgt[0] - avgt[1]);\n    return Goodness;  // 反比关系\n}\n\n"}]],["0",[{"text":"#include \"BluetMCPAnodeMaster.h\"\n#include \"BluetConfig.h\"\n#include \"cmath\"\n#include \"iostream\"\n#include <numeric> \n\nusing namespace std;\n\nBluetMCPAnodeMaster* BluetMCPAnodeMaster::fInstance = 0;\n\n//-----------------------------------------\n// BluetMCPAnodeMaster()\n//-----------------------------------------\nBluetMCPAnodeMaster::BluetMCPAnodeMaster()\n:DrawOpt(false),\nDir_Pic(\"\"),\ninittime(-100000),\nispark(-1),\nsizeX(1024),\nsizeY(2024),\n//timewindow(10.),\ntimewindow(2.),\nWaveLength(0),\nTimeStamp(0),\nncanvas(1)\n{\n    \n    // ----- set map -----\n    config = BluetConfig::GetInstance();\n\tconfig->ReadConfigFile();\n    Nboard = config->GetNboard(); // board == 4 preamp\n    Nchip = config->GetNchip();  //  chip == 2 ADM\n    Nchannel = config->GetNchannel(); // channel == 32 channel\n\n    sampleT = config->GetWaveformSamplingPeriod(); // [ns]\n    stampT = config->GetTimeStampPeriod(); //[ns]\n    TimeStampCutTrig0 = config->GetTimeStampCutTrig0();\n    WaveLength = config->GetWaveLength0();\n\n    // ----- set anode -----\n    NstripX = config->GetNstripX();\n    NstripY = config->GetNstripY();\n    Pitch = config->GetStripPitch();\n    double sidelengthx = Pitch*NstripX;\n    double sidelengthy = Pitch*NstripY;\n    \n/*     hanode0 = new TH2F(\"hanode0\", \"hanode0;Xstrip;Ystrip\", NstripX, 0, NstripX, NstripY, 0, NstripY);\n    hanode0->GetXaxis()->CenterTitle(); hanode0->GetYaxis()->CenterTitle(); */\n    hanode1 = new TH2F(\"hanode1\", \"hanode1;Xpos [mm];Ypos [mm]\", NstripX, 0., sidelengthx, NstripY, 0., sidelengthy);\n    hanode1->GetXaxis()->CenterTitle(); hanode1->GetYaxis()->CenterTitle();\n    ht0 = new TH1F(\"ht0\", \"ht0;time [point];count\", WaveLength*5, 0, WaveLength);\n    ht0->GetXaxis()->CenterTitle(); ht0->GetYaxis()->CenterTitle();\n    ht0tot = new TH1F(\"ht0tot\", \"hht0tott0;time [point];count\", WaveLength*5, 0, WaveLength);\n    ht0tot->GetXaxis()->CenterTitle(); ht0tot->GetYaxis()->CenterTitle();    \n    hanodex = new TH1F(\"hanodex\", \"hanodex;Xpos [mm];count\", NstripX, 0, NstripX*Pitch);\n    hanodex->GetXaxis()->CenterTitle(); hanodex->GetYaxis()->CenterTitle();\n    hanodey = new TH1F(\"hanodey\", \"hanodey;Ypos [mm];count\", NstripY, 0, NstripY*Pitch);\n    hanodey->GetXaxis()->CenterTitle(); hanodey->GetYaxis()->CenterTitle();\n        \n\n//    \n    fEvent = new BluetEvent();\n    fWavehit = new BluetWaveHit();    \n}\n\n//-----------------------------------------\n// SetCanvasSize()\n//-----------------------------------------\nvoid BluetMCPAnodeMaster::SetCanvasSize(int _sizeX, int _sizeY){\n  sizeX = _sizeX;\n  sizeY = _sizeY;\n}\n\n//-----------------------------------------\n// InitCanvas()\n//-----------------------------------------\nvoid BluetMCPAnodeMaster::InitCanvas(){\n\n  //TCanvas  \n    for (size_t i = 0; i < ncanvas; i++)\n    {\n        auto c = new TCanvas(Form(\"c%d\", i), Form(\"c%d\", i), sizeX, sizeY); //vec_canvas[0]->Divide(Ncol, Nrow);\n        vec_canvas.emplace_back(c);\n    }\n    canode = new TCanvas(\"canode\", \"canode\", sizeX, sizeX/2);\n    DrawOpt = true;\n\n    cout << \"NCanvas=\" << ncanvas  << endl;\n}\n\n//-----------------------------------------\n// print_map()\n//-----------------------------------------\nvoid BluetMCPAnodeMaster::print_map(){\n     std::cout << \"print_map\"<<endl;\n    // Iterate using C++17 facilities\n    for (const auto& [key, value] : map_channel_strip){\n        cout << '[' ; \n        std::cout  << \" => { \" << std::get<0>(key) << \", \"\n                                          << std::get<1>(key) << \", \"\n                                          << std::get<2>(key) << \" }\" ;\n        cout << \"] = \" << value << endl;\n    }\n    // // C++11 alternative:\n    //  for (const auto& n : m)\n    //      std::cout << n.first << \" = \" << n.second << \"; \";\n    //\n\n    std::cout << '\\n';\n}\n\n\n\n//-----------------------------------------\n// print_N()\n//-----------------------------------------\nvoid BluetMCPAnodeMaster::print_N(){\n    cout<<\"BluetMCPAnodeMaster::print_N()\"<<endl;    \n    cout<<Nchip << \"\\t\"  <<Nchannel << \"\\t\" <<Nboard<<endl;\n}\n\n//-----------------------------------------\n// map_to_strip()\n//-----------------------------------------\nint BluetMCPAnodeMaster::map_to_strip(int board, int chip, int channel){\n    std::tuple<int, int, int> channel_fullname = {board, chip, channel};\n    auto key = map_channel_strip.find(channel_fullname);\n    return key->second;\n}\n\n\n//-----------------------------------------\n// GetInstance()\n//-----------------------------------------\nBluetMCPAnodeMaster* BluetMCPAnodeMaster::GetInstance()\n{\n  if( fInstance == 0 ) fInstance = new BluetMCPAnodeMaster();\n  return fInstance;\n}\n\n//-----------------------------------------\n// SetWaveHit()\n//-----------------------------------------\nvoid BluetMCPAnodeMaster::SetWaveHit(BluetWaveHit* bwavehit){\n    fWavehit = bwavehit;\n    TimeStamp = bwavehit->TimeStamp;\n    if (fWavehit->TimeStamp<TimeStampCutTrig0)\n    {\n        WaveLength = config->GetWaveLength0();\n    }else\n    {\n        WaveLength = config->GetWaveLength();\n    }\n}\n\n//-----------------------------------------\n// HitCut()\n//-----------------------------------------\nbool BluetMCPAnodeMaster::HitCut(const array<double,6>& par){\n    bool cut0 = false;\n/*     if(par[0]>15)\n    cut0 = true; */\n    bool cut1 = false;\n    //if((par[0]>10. && par[0]<=3000. && par[2]>0.06 && par[2]<0.2) || (par[0]>3000. && par[2]>0.06 && par[2]<0.2) )\n    if((par[0]>15. && par[0]<=3000. && par[2]>0.06 && par[2]<0.4) || (par[0]>3000. && par[2]>0.06 && par[2]<0.4) )\n    cut0 = true;\n    if((par[0]>15. && par[0]<=3000. && par[5]/par[0]>0.08 && par[5]/par[0]<2.)||(par[0]>3000 && par[5]/par[0]>0.04 && par[5]/par[0]<1.5)) cut1 = true;\n    //if((par[0]>10. && par[0]<=3000. && par[5]/par[0]>0.6 && par[5]/par[0]<1.4) || (par[0]>3000 && par[5]/par[0]>0.3 && par[5]/par[0]<1.4))\n    //if((TimeStamp<=TimeStampCutTrig0 && par[5]/par[0]>0.3 && par[5]/par[0]<3) || (TimeStamp>TimeStampCutTrig0 && par[5]/par[0]>0.03 && par[5]/par[0]<3))\n     cut1 = true;\n    return (cut0 && cut1);\n/*     return cut0;  */    \n}\n\n//-----------------------------------------\n// HitCut()\n//-----------------------------------------\nbool BluetMCPAnodeMaster::HitCut(const BluetWavePara& par){\n    bool cut0 = false;\n    bool cut1 = false;\n    if((par.HitAmp>15. && par.HitAmp<=3000. && par.HitTau>0.06 && par.HitTau<0.4) || (par.HitAmp>3000. && par.HitTau>0.06 && par.HitTau<0.4) )\n    cut0 = true;\n/*     if((ppar.HitAmp>15. && par.HitAmp<=3000. && par[5]/par[0]>0.08 && par[5]/par[0]<2.)||(par[0]>3000 && par[5]/par[0]>0.04 && par[5]/par[0]<1.5)) \n    cut1 = true; */\n    cut1 = true;    \n    return (cut0 && cut1);\n}\n\n\n//-----------------------------------------\n// SetDrawHit()\n//-----------------------------------------\nvoid BluetMCPAnodeMaster::SetDrawHit(vector<int> *boardID, vector<int> *chipID, vector<int> *channelID, const vector<array<double,6>>& v_fitpar, bool drawOpt, bool printOpt)\n{\n    DrawOpt = drawOpt;  \n    ispark = 0;\n    // ----- reset ----- \n   \n    HitReset();\n\n    // ----- push hit ----- \n    for(int ihit=0; ihit<v_fitpar.size(); ++ihit){\n        auto fitpar = v_fitpar[ihit];\n        array<int,3> index{boardID->at(ihit), chipID->at(ihit), channelID->at(ihit)}; \n        HitProcess(index, fitpar);        \n    } // end of ihit loop\n\n    // ----- push Spark -----  \n    SparkProcess(printOpt);\n    // ----- fill event -----\n    if(!DrawOpt){\n        EndEvent();\n    }else{\n        canode->Update();\n    }\n}\n\n\n\n//-----------------------------------------\n// SetDrawHit2()\n//-----------------------------------------\nvoid BluetMCPAnodeMaster::SetDrawHit2(vector<int> *boardID, vector<int> *chipID, vector<int> *channelID, const vector<vector<array<double, 6>>>& fitpar, bool drawOpt, bool printOpt){\n    DrawOpt = drawOpt;\n\n    // ----- reset ----- \n    if(DrawOpt) {\n        canode->Clear();\n        canode->Divide(4, 4);   \n    }\n    multimap<double, st_data> map_fitpar{};\n\n    for (size_t i = 0; i < fitpar.size(); i++)\n    {\n        array<int,3> index{boardID->at(i), chipID->at(i), channelID->at(i)}; \n\n        for (auto content: fitpar[i])\n        {\n            st_data ss{};\n            ss.fitpar =  content;\n            ss.index = index;\n            auto t = content[1];\n            map_fitpar.emplace(t, ss);\n        }\n    }\n    bool flag{false};\n\n    for (const auto& ppara: map_fitpar)\n    {\n        auto tcurr = ppara.first;\n        auto index1 = ppara.second.index;\n        auto fitpar = ppara.second.fitpar;     \n\n        if (flag)\n        {\n            if (TMath::Abs(tcurr-inittime) <= timewindow)\n            {\n                HitProcess(index1, fitpar);\n            }else\n            {\n                SparkProcess(printOpt);\n                InitEvent(tcurr);\n                HitProcess(index1, fitpar);\n            }\n        }else\n        {\n            InitEvent(tcurr);\n            HitProcess(index1, fitpar);            \n            flag = true;\n        }\n    }\n\n/*     if (fEvent->Hits.size()>0)\n    {\n        SparkProcess(printOpt);\n    } */\n    \n\n    /*SparkProcess(printOpt);\n    if(!DrawOpt){\n        EndEvent();\n    }*/\n\n    // ----- draw ----- \n    if(DrawOpt){\n        canode->Update();\n    }\n\n}\n\n//-----------------------------------------\n// ReEvent()\n//-----------------------------------------\nvoid BluetMCPAnodeMaster::ReEvent(bool drawOpt, bool printOpt){\n    DrawOpt = drawOpt;\n    ispark = 0;\n\n    // ----- reset ----- \n    if(DrawOpt) {\n        for (const auto c : vec_canvas)\n        {\n            c->Clear(); \n            c->Divide(4,4);\n        }\n        canode->Clear();\n        ht0tot->Reset();\n    } \n/*     cout << ispark << \"\\t\" << \"test7\\n\" << endl;     */            \n\n    // ---- Divided by time ---- \n    bool flag{false};    \n    for (const auto& ppara: fWavehit->WavePara)\n    {\n        auto tcurr = ppara.HitT;\n        ht0tot->Fill(tcurr);\n        if (flag)\n        {\n            if (TMath::Abs(tcurr-inittime) <= timewindow)\n            {\n                HitProcess2(ppara);\n            }else\n            {\n/*                 cout << ispark << \"\\t\" << tcurr << endl;            */     \n                SparkProcess2(printOpt);\n                InitEvent2(tcurr);\n                HitProcess2(ppara);\n/*                 cout << ispark << \"\\t\" << tcurr <<\"\\n\" << endl;    */             \n            }\n        }else\n        {\n            InitEvent2(tcurr);\n            HitProcess2(ppara);         \n            flag = true;\n        }\n    }\n\n    if (HitParaX.size()>0&&HitParaY.size()>0)\n    {\n        SparkProcess2(printOpt);\n    }\n/*     cout << ispark << \"\\t\" << \"test7\\n\" << endl;        */         \n\n    // ----- draw ----- \n    if(DrawOpt){\n        canode->cd();\n        ht0tot->DrawCopy(\"\");\n        for (const auto c : vec_canvas)\n        {\n            c->Update(); \n        }\n        canode->Update();\n    }else\n    {\n        EndEvent();\n    }\n    \n}\n\n//-----------------------------------------\n// Drawpic()\n//-----------------------------------------\nint BluetMCPAnodeMaster::Drawpic(){\n    auto icanvas = (ispark-1)/8;\n    auto ipad = (ispark-1)%8;\n    if (icanvas>ncanvas-1)\n    {\n        return -1;\n    }\n    \n    vec_canvas[icanvas]->cd(ipad*2+1);\n    hanode1->DrawCopy(\"colz\");\n    vec_canvas[icanvas]->cd(ipad*2+2);\n    ht0->GetXaxis()->SetRange(max(ht0->FindFirstBinAbove() - 25,1), min(ht0->FindLastBinAbove() + 25, WaveLength*10)); \n    ht0->DrawCopy(\"\");    \n\n    return 1;\n}\n\n//-----------------------------------------\n// EndEvent()\n//-----------------------------------------\nvoid BluetMCPAnodeMaster::EndEvent(){\n    fEvent->EventCount = fWavehit->EventCount;\n    fEvent->TimeStamp = fWavehit->TimeStamp;\n    eventTree->Fill();\n    fEvent->Reset();\n}\n\n//-----------------------------------------\n// HitReset()\n//-----------------------------------------     \nvoid BluetMCPAnodeMaster::HitReset(){\n    // ----- reset ----- \n    ht0->Reset();   \n    HitposX.clear();\n    HitposY.clear();\n    HittimeX.clear();\n    HittimeY.clear();\n    HitampX.clear();\n    HitampY.clear();\n    fEvent->Reset();\n}\n\n//-----------------------------------------\n// HitReset2()\n//-----------------------------------------     \nvoid BluetMCPAnodeMaster::HitReset2(){\n    // ----- reset ----- \n    HitParaX.clear();\n    HitParaY.clear();    \n}\n\n//-----------------------------------------\n// InitEvent()\n//-----------------------------------------\nvoid BluetMCPAnodeMaster::InitEvent(double tcurr){\n    HitReset();       \n    inittime = tcurr;\n}\n\n//-----------------------------------------\n// InitEvent2()\n//-----------------------------------------\nvoid BluetMCPAnodeMaster::InitEvent2(double tcurr){\n    // ----- reset ----- \n    HitReset2();   \n    inittime = tcurr;    \n}\n\n\n//-----------------------------------------\n// HitProcess()\n//-----------------------------------------\nvoid BluetMCPAnodeMaster::HitProcess(const array<int, 3>& index, const array<double, 6>& fitpar){\n\n        auto stripID = map_to_strip(index[0], index[1], index[2]);\n        BluetHit fHit{};\n        if(stripID<NstripX) {\n            if(HitCut(fitpar)){\n                HitposX.emplace_back((stripID+0.5)*Pitch);\n                HitampX.emplace_back(fitpar[0]);\n                HittimeX.emplace_back(fitpar[1]);\n            }\n            fHit.HitAmp = fitpar[0];\n            fHit.HitT = fitpar[1];\n            fHit.HitTau = fitpar[2];\n            fHit.HitBaseline = fitpar[3];\n            fHit.HitChi2 = fitpar[4];\n            fHit.HitPeakVal = fitpar[5];\n            fHit.HitPos = (stripID+0.5)*Pitch;\n            fHit.HitBoardID = index[0]; \n            fHit.HitChipID = index[1]; \n            fHit.HitChannelID = index[2]; \n            if(DrawOpt){\n                cout<<\"Xstrip >>> DAQ-ID: \"<<fHit.HitBoardID<<\"-\"<<fHit.HitChipID<<\"-\"<<fHit.HitChannelID\n                            <<\", stripID = \"<<stripID<<\", xpos = \"<<(stripID+0.5)*Pitch<<endl;\n                for(int ibin=0; ibin<NstripY; ibin++) {\n                    hanode1->Fill((stripID+0.5)*Pitch, (ibin+0.5)*Pitch, fitpar[0]); \n                }          \n            }\n                ht0->Fill(fitpar[1]);                \n        }\n        \n        if(stripID>=NstripX) {\n            if(HitCut(fitpar)){\n                HitposY.emplace_back((stripID-NstripX+0.5)*Pitch);\n                HitampY.emplace_back(fitpar[0]);\n                HittimeY.emplace_back(fitpar[1]);\n            }\n            fHit.HitAmp = fitpar[0];\n            fHit.HitT = fitpar[1];\n            fHit.HitTau = fitpar[2];\n            fHit.HitBaseline = fitpar[3];\n            fHit.HitChi2 = fitpar[4];\n            fHit.HitPeakVal = fitpar[5];\n            fHit.HitPos = (stripID+0.5)*Pitch;\n            fHit.HitTypeName = \"StripY\";\n            fHit.HitBoardID = index[0]; \n            fHit.HitChipID = index[1]; \n            fHit.HitChannelID = index[2]; \n            if(DrawOpt){\n                cout<<\"Ystrip >>> DAQ-ID: \"<<fHit.HitBoardID<<\"-\"<<fHit.HitChipID<<\"-\"<<fHit.HitChannelID\n                <<\", stripID = \"<<stripID<<\", ypos = \"<<(stripID-NstripX+0.5)*Pitch<<endl;\n                for(int ibin=0; ibin<NstripX; ibin++) {\n/*                     hanode0->Fill(ibin, stripID-NstripX, fitpar[0]); */\n                    hanode1->Fill((ibin+0.5)*Pitch, (stripID-NstripX+0.5)*Pitch, fitpar[0]);    \n                }\n            }\n                ht0->Fill(fitpar[1]);\n        }\n/*         fEvent->Hits.emplace_back(fHit); */\n\n}\n\n//-----------------------------------------\n// HitProcess2()\n//-----------------------------------------\n\nvoid BluetMCPAnodeMaster::HitProcess2(const BluetWavePara& par){\n    \n    if(HitCut(par) == false) return;\n    auto stripID = par.HitStripID;\n    wavepara_data w_d{};\n    if(stripID<NstripX) {\n        w_d.HitPos = (stripID+0.5)*Pitch;\n        w_d.HitAmp = par.HitAmp;\n        w_d.HitTime = par.HitTime;\n        w_d.HitT = par.HitT;\n        HitParaX.emplace_back(w_d);\n    }\n\n    if(stripID>=NstripX) {\n        w_d.HitPos = (stripID-NstripX+0.5)*Pitch;\n        w_d.HitAmp = par.HitAmp;\n        w_d.HitTime = par.HitTime;\n        w_d.HitT = par.HitT;        \n        HitParaY.emplace_back(w_d);\n    }\n\n}\n\n//-----------------------------------------\n// SparkProcess()\n//-----------------------------------------\nint BluetMCPAnodeMaster::SparkProcess(bool printOpt){\n   \n    if( HitposX.size()==0 || HitposY.size()==0 ) \n    return -1;\n    ispark++;\n    if (DrawOpt)\n    {\n        Drawpic();\n    }\n \n    BluetSpark fSpark;\n    fSpark.Nhits = HitposX.size() + HitposY.size();\n    fSpark.NhitsX = HitposX.size();\n    fSpark.NhitsY = HitposY.size();\n    fSpark.TminX = *min_element(HittimeX.begin(), HittimeX.end());\n    fSpark.TminY = *min_element(HittimeY.begin(), HittimeY.end());\n    fSpark.TmaxX = *max_element(HittimeX.begin(), HittimeX.end());\n    fSpark.TmaxY = *max_element(HittimeY.begin(), HittimeY.end());\n    auto minT = min(fSpark.TminX, fSpark.TminY);\n    fSpark.TOF0 = (double)TimeStamp*stampT - (double)WaveLength*sampleT + minT*sampleT;\n    \n    double sumEx = 0.;\n    double weightx = 0.;\n    //double posx = 0.;\n    for(int ix=0; ix<HitposX.size(); ++ix){\n        weightx = weightx + HitposX[ix]*HitampX[ix];\n        //posx = posx + HitposX[ix];\n        sumEx = sumEx + HitampX[ix];\n    }\n    \n    double sumEy = 0.;\n    double weighty = 0.;\n    //double posy = 0.;\n    for(int iy=0; iy<HitposY.size(); ++iy){\n        weighty = weighty + HitposY[iy]*HitampY[iy];\n        //posy = posy + HitposY[iy];\n        sumEy = sumEy + HitampY[iy];\n    }\n\n    if( sumEx!=0. && sumEy!=0.){\n        fSpark.CentroidPos[0] = weightx/sumEx;\n        fSpark.CentroidPos[1] = weighty/sumEy;\n    }\n    \n    fSpark.SparkSumE = sumEx + sumEy;\n    fSpark.SigmaT = ht0->GetStdDev();\n    fEvent->Sparks.emplace_back(fSpark);\n    if(printOpt){\n        cout<<\"\\nCentroidPos:  x = \"<<fSpark.CentroidPos[0]<<\" y = \"<<fSpark.CentroidPos[1]<<endl;\n        cout<<\"SparkSumE = \"<<fSpark.SparkSumE<<endl;\n        cout<<\"SigmaT = \"<<ht0->GetStdDev()<<endl;\n    }\n\n    if (DrawOpt)\n    {\n        hanode1->Reset();   \n        ht0->Reset();  \n    }\n    \n    return 1;\n\n}\n\n\nint BluetMCPAnodeMaster::SparkProcess2(bool printOpt){\n\n    if( HitParaX.size()==0 || HitParaY.size()==0 ) \n    return -1;\n\n    //sort by StripID/HitPos\n    sort(HitParaX.begin(), HitParaX.end(), comparewavedata);\n    sort(HitParaY.begin(), HitParaY.end(), comparewavedata);\n    \n    //Divide by StripID/HitPos\n    vector<vector<wavepara_data>> gHitParaX;\n    vector<vector<wavepara_data>> gHitParaY;\n    auto Pitch_ = Pitch;\n    auto divide_space = [Pitch_](vector<vector<wavepara_data>>& gHitPara, vector<wavepara_data>& HitPara){\n        vector<wavepara_data> tempHitPara;\n        tempHitPara.emplace_back(HitPara[0]);\n        for (size_t i = 0; i < HitPara.size() - 1; i++)\n        {\n            auto df = abs(HitPara[i+1].HitPos - HitPara[i].HitPos);\n            if (df <= 2*Pitch_)\n            {\n                tempHitPara.emplace_back(HitPara[i+1]);\n            }else\n            {\n                gHitPara.emplace_back(tempHitPara);\n                tempHitPara.clear();\n                tempHitPara.emplace_back(HitPara[i+1]);\n            }\n        }\n        if (!tempHitPara.empty()) {\n            gHitPara.emplace_back(tempHitPara);\n        }\n    };\n\n    divide_space(gHitParaX, HitParaX);\n    divide_space(gHitParaY, HitParaY);   \n\n\n    // rebuild by Goodness\n    auto nxevent = gHitParaX.size();\n    auto nyevent = gHitParaY.size();\n    auto nevent = min(nxevent, nyevent);\n    \n\n    vector<vector<double>> vGoodness(nxevent, vector<double>(nyevent));\n\n    for (size_t i = 0; i < gHitParaX.size(); i++)\n    {\n        for (size_t j = 0; j < gHitParaY.size(); j++)\n        {\n            vGoodness[i][j] = calculateGoodness(gHitParaX[i], gHitParaY[j]);\n        }\n    }\n\n    vector<std::array<int,2>> vMatchId{};\n    for (int ievent = 0; ievent < nevent; ievent++)\n    {\n        double minGoodness = std::numeric_limits<double>::max();\n        int minRow = 0, minCol = 0;            \n        for (int i = 0; i < nxevent; ++i) {\n            for (int j = 0; j < nyevent; ++j) {\n                if (vGoodness[i][j] < minGoodness) {\n                    minGoodness = vGoodness[i][j];\n                    minRow = i; \n                    minCol = j; \n                }\n            }\n        }\n        std::array<int,2> gid = {minRow,minCol};\n        vMatchId.emplace_back(gid);\n        // minrow and mincol set as max\n        for (size_t j = 0; j < nyevent; ++j) {\n            vGoodness[minRow][j] = std::numeric_limits<double>::max();\n        }\n\n        for (size_t i = 0; i < nxevent; ++i) {\n            vGoodness[i][minCol] = std::numeric_limits<double>::max();\n        }            \n    }\n\n    for (const auto & id: vMatchId)\n    {\n        ispark++;\n        BluetSpark fSpark;\n        \n        fSpark.NhitsX = gHitParaX[id[0]].size();\n        fSpark.NhitsY = gHitParaY[id[1]].size();    \n//        std::cout << gHitParaX[id[0]].size() << \"\\t\" << gHitParaY[id[1]].size()  << \"\\t\" << vMatchId.size()<< endl;\n        fSpark.Nhits = fSpark.NhitsX + fSpark.NhitsY;\n        fSpark.TminX = std::numeric_limits<double>::max();\n        fSpark.TmaxX = 0;  \n        fSpark.TminY = std::numeric_limits<double>::max();\n        fSpark.TmaxY = 0;\n        double sumEx = 0.;\n        double sumEy = 0.;\n        double weightx = 0.;\n        double weighty = 0.;\n        \n        for (const auto & temppara: gHitParaX[id[0]])\n        {\n            if (temppara.HitT < fSpark.TminX){\n                fSpark.TminX = temppara.HitT;\n            }\n            if (temppara.HitT > fSpark.TmaxX)\n            {\n                fSpark.TmaxX = temppara.HitT;\n            }\n            weightx = weightx + temppara.HitAmp*temppara.HitPos;\n            sumEx = sumEx + temppara.HitAmp;\n            hanodex->Fill(temppara.HitPos, temppara.HitAmp);\n            ht0->Fill(temppara.HitT);\n            \n            if (DrawOpt)\n            {\n                cout << \"Xstrip >>> xpos = \" << temppara.HitPos << endl;\n                for(int ibin=0; ibin<NstripX; ibin++) {\n                    hanode1->Fill(temppara.HitPos, (ibin+0.5)*Pitch, temppara.HitAmp); \n                }  \n            }\n        }\n        \n        for (const auto & temppara: gHitParaY[id[1]])\n        {\n            if (temppara.HitT < fSpark.TminY){\n                fSpark.TminY = temppara.HitT;\n            }\n            if (temppara.HitT > fSpark.TmaxY)\n            {\n                fSpark.TmaxY = temppara.HitT;\n            }\n            weighty = weighty + temppara.HitAmp*temppara.HitPos;\n            sumEy = sumEy + temppara.HitAmp;\n            hanodey->Fill(temppara.HitPos, temppara.HitAmp);\n            ht0->Fill(temppara.HitT);     \n            if (DrawOpt)\n            {\n                cout << \"Ystrip >>> ypos = \" << temppara.HitPos << endl;\n                for(int ibin=0; ibin<NstripY; ibin++) {\n                    hanode1->Fill((ibin+0.5)*Pitch, temppara.HitPos, temppara.HitAmp); \n                }  \n            }     \n        }\n        fSpark.CentroidPos[0] = weightx/sumEx;\n        fSpark.CentroidPos[1] = weighty/sumEy;\n\n        fSpark.SparkSumE = sumEx + sumEy;\n        fSpark.SigmaT = ht0->GetStdDev();\n        fSpark.SigmaX = hanodex->GetStdDev();\n        fSpark.SigmaY = hanodey->GetStdDev();\n        auto minT = min(fSpark.TminX, fSpark.TminY);\n        fSpark.TOF0 = (double)TimeStamp*stampT - (double)WaveLength*sampleT + minT*sampleT;\n\n        fEvent->Sparks.emplace_back(fSpark);\n        if(printOpt){\n            cout<<\"\\nCentroidPos:  x = \"<<fSpark.CentroidPos[0]<<\" y = \"<<fSpark.CentroidPos[1]<<endl;\n            cout<<\"SparkSumE = \"<<fSpark.SparkSumE<<endl;\n            cout<<\"T = \"<<minT<<endl;\n            cout<<\"<<<<<<<<<<<<<<<<<<<<<\"<<endl;\n/*             cout << Form(\"WaveLength = %d, TimeStamp = %d, sampleT = %f\", WaveLength, TimeStamp, sampleT) << endl;\n */        }\n\n    \n        if (DrawOpt)\n        {        \n            Drawpic();    \n            hanode1->Reset();   \n        }\n        hanodex->Reset();\n        hanodey->Reset();   \n        ht0->Reset();            \n    }\n    return 1;\n\n}\n\nvoid BluetMCPAnodeMaster::OutputPicture(){\n  if (Dir_Pic!=\"\")\n  {\n    for (size_t i = 0; i < ncanvas; i++)\n    {\n        vec_canvas[i]->SaveAs(Form(\"%s/c%d.png\", Dir_Pic.data(), i));\n    }\n    canode->SaveAs(Form(\"%s/Anode.png\", Dir_Pic.data()));\n  }else{\n    cout << \"Dir of picture was not found!!\" << endl; \n  }    \n}\n\n//-----------------------------------------\n// CompareWavedata()\n//-----------------------------------------\nbool BluetMCPAnodeMaster::comparewavedata(const wavepara_data& a, const wavepara_data& b){\n    return a.HitPos < b.HitPos;\n}\n\n//-----------------------------------------\n// calculateGoodness()\n//-----------------------------------------\ndouble BluetMCPAnodeMaster::calculateGoodness(const vector<wavepara_data>& vx, const vector<wavepara_data>& vy) {\n    array<double ,2> nhit = {vx.size(), vy.size()};\n    array<double ,2> sumAmp;\n    array<double ,2> sumT;\n    array<double ,2> avgt;\n    //array<double ,2> stddet;    \n    for (size_t i = 0; i < nhit[0]; i++)\n    {\n        sumAmp[0] = vx[i].HitAmp;\n        sumT[0] = vx[i].HitT;\n    }\n\n    for (size_t i = 0; i < nhit[1]; i++)\n    {\n        sumAmp[1] = vy[i].HitAmp;\n        sumT[1] = vy[i].HitT;\n    }  \n\n    for (size_t i = 0; i < 2; i++)\n    {\n        avgt[i] = sumT[i]/nhit[i];\n    }\n      \n    auto Goodness = (nhit[0]-nhit[1])*(nhit[0]-nhit[1]) + 0.5*(sumAmp[0] - sumAmp[1])*(sumAmp[0] - sumAmp[1]) + 0.2*(avgt[0] - avgt[1])*(avgt[0] - avgt[1]);\n    return Goodness;  // 反比关系\n}\n\n","registerMode":0}]],["\"",[{"registerMode":0,"text":"#include \"BluetMCPAnodeMaster.h\"\n#include \"BluetConfig.h\"\n#include \"cmath\"\n#include \"iostream\"\n#include <numeric> \n\nusing namespace std;\n\nBluetMCPAnodeMaster* BluetMCPAnodeMaster::fInstance = 0;\n\n//-----------------------------------------\n// BluetMCPAnodeMaster()\n//-----------------------------------------\nBluetMCPAnodeMaster::BluetMCPAnodeMaster()\n:DrawOpt(false),\nDir_Pic(\"\"),\ninittime(-100000),\nispark(-1),\nsizeX(1024),\nsizeY(2024),\n//timewindow(10.),\ntimewindow(2.),\nWaveLength(0),\nTimeStamp(0),\nncanvas(1)\n{\n    \n    // ----- set map -----\n    config = BluetConfig::GetInstance();\n\tconfig->ReadConfigFile();\n    Nboard = config->GetNboard(); // board == 4 preamp\n    Nchip = config->GetNchip();  //  chip == 2 ADM\n    Nchannel = config->GetNchannel(); // channel == 32 channel\n\n    sampleT = config->GetWaveformSamplingPeriod(); // [ns]\n    stampT = config->GetTimeStampPeriod(); //[ns]\n    TimeStampCutTrig0 = config->GetTimeStampCutTrig0();\n    WaveLength = config->GetWaveLength0();\n\n    // ----- set anode -----\n    NstripX = config->GetNstripX();\n    NstripY = config->GetNstripY();\n    Pitch = config->GetStripPitch();\n    double sidelengthx = Pitch*NstripX;\n    double sidelengthy = Pitch*NstripY;\n    \n/*     hanode0 = new TH2F(\"hanode0\", \"hanode0;Xstrip;Ystrip\", NstripX, 0, NstripX, NstripY, 0, NstripY);\n    hanode0->GetXaxis()->CenterTitle(); hanode0->GetYaxis()->CenterTitle(); */\n    hanode1 = new TH2F(\"hanode1\", \"hanode1;Xpos [mm];Ypos [mm]\", NstripX, 0., sidelengthx, NstripY, 0., sidelengthy);\n    hanode1->GetXaxis()->CenterTitle(); hanode1->GetYaxis()->CenterTitle();\n    ht0 = new TH1F(\"ht0\", \"ht0;time [point];count\", WaveLength*5, 0, WaveLength);\n    ht0->GetXaxis()->CenterTitle(); ht0->GetYaxis()->CenterTitle();\n    ht0tot = new TH1F(\"ht0tot\", \"hht0tott0;time [point];count\", WaveLength*5, 0, WaveLength);\n    ht0tot->GetXaxis()->CenterTitle(); ht0tot->GetYaxis()->CenterTitle();    \n    hanodex = new TH1F(\"hanodex\", \"hanodex;Xpos [mm];count\", NstripX, 0, NstripX*Pitch);\n    hanodex->GetXaxis()->CenterTitle(); hanodex->GetYaxis()->CenterTitle();\n    hanodey = new TH1F(\"hanodey\", \"hanodey;Ypos [mm];count\", NstripY, 0, NstripY*Pitch);\n    hanodey->GetXaxis()->CenterTitle(); hanodey->GetYaxis()->CenterTitle();\n        \n\n//    \n    fEvent = new BluetEvent();\n    fWavehit = new BluetWaveHit();    \n}\n\n//-----------------------------------------\n// SetCanvasSize()\n//-----------------------------------------\nvoid BluetMCPAnodeMaster::SetCanvasSize(int _sizeX, int _sizeY){\n  sizeX = _sizeX;\n  sizeY = _sizeY;\n}\n\n//-----------------------------------------\n// InitCanvas()\n//-----------------------------------------\nvoid BluetMCPAnodeMaster::InitCanvas(){\n\n  //TCanvas  \n    for (size_t i = 0; i < ncanvas; i++)\n    {\n        auto c = new TCanvas(Form(\"c%d\", i), Form(\"c%d\", i), sizeX, sizeY); //vec_canvas[0]->Divide(Ncol, Nrow);\n        vec_canvas.emplace_back(c);\n    }\n    canode = new TCanvas(\"canode\", \"canode\", sizeX, sizeX/2);\n    DrawOpt = true;\n\n    cout << \"NCanvas=\" << ncanvas  << endl;\n}\n\n//-----------------------------------------\n// print_map()\n//-----------------------------------------\nvoid BluetMCPAnodeMaster::print_map(){\n     std::cout << \"print_map\"<<endl;\n    // Iterate using C++17 facilities\n    for (const auto& [key, value] : map_channel_strip){\n        cout << '[' ; \n        std::cout  << \" => { \" << std::get<0>(key) << \", \"\n                                          << std::get<1>(key) << \", \"\n                                          << std::get<2>(key) << \" }\" ;\n        cout << \"] = \" << value << endl;\n    }\n    // // C++11 alternative:\n    //  for (const auto& n : m)\n    //      std::cout << n.first << \" = \" << n.second << \"; \";\n    //\n\n    std::cout << '\\n';\n}\n\n\n\n//-----------------------------------------\n// print_N()\n//-----------------------------------------\nvoid BluetMCPAnodeMaster::print_N(){\n    cout<<\"BluetMCPAnodeMaster::print_N()\"<<endl;    \n    cout<<Nchip << \"\\t\"  <<Nchannel << \"\\t\" <<Nboard<<endl;\n}\n\n//-----------------------------------------\n// map_to_strip()\n//-----------------------------------------\nint BluetMCPAnodeMaster::map_to_strip(int board, int chip, int channel){\n    std::tuple<int, int, int> channel_fullname = {board, chip, channel};\n    auto key = map_channel_strip.find(channel_fullname);\n    return key->second;\n}\n\n\n//-----------------------------------------\n// GetInstance()\n//-----------------------------------------\nBluetMCPAnodeMaster* BluetMCPAnodeMaster::GetInstance()\n{\n  if( fInstance == 0 ) fInstance = new BluetMCPAnodeMaster();\n  return fInstance;\n}\n\n//-----------------------------------------\n// SetWaveHit()\n//-----------------------------------------\nvoid BluetMCPAnodeMaster::SetWaveHit(BluetWaveHit* bwavehit){\n    fWavehit = bwavehit;\n    TimeStamp = bwavehit->TimeStamp;\n    if (fWavehit->TimeStamp<TimeStampCutTrig0)\n    {\n        WaveLength = config->GetWaveLength0();\n    }else\n    {\n        WaveLength = config->GetWaveLength();\n    }\n}\n\n//-----------------------------------------\n// HitCut()\n//-----------------------------------------\nbool BluetMCPAnodeMaster::HitCut(const array<double,6>& par){\n    bool cut0 = false;\n/*     if(par[0]>15)\n    cut0 = true; */\n    bool cut1 = false;\n    //if((par[0]>10. && par[0]<=3000. && par[2]>0.06 && par[2]<0.2) || (par[0]>3000. && par[2]>0.06 && par[2]<0.2) )\n    if((par[0]>15. && par[0]<=3000. && par[2]>0.06 && par[2]<0.4) || (par[0]>3000. && par[2]>0.06 && par[2]<0.4) )\n    cut0 = true;\n    if((par[0]>15. && par[0]<=3000. && par[5]/par[0]>0.08 && par[5]/par[0]<2.)||(par[0]>3000 && par[5]/par[0]>0.04 && par[5]/par[0]<1.5)) cut1 = true;\n    //if((par[0]>10. && par[0]<=3000. && par[5]/par[0]>0.6 && par[5]/par[0]<1.4) || (par[0]>3000 && par[5]/par[0]>0.3 && par[5]/par[0]<1.4))\n    //if((TimeStamp<=TimeStampCutTrig0 && par[5]/par[0]>0.3 && par[5]/par[0]<3) || (TimeStamp>TimeStampCutTrig0 && par[5]/par[0]>0.03 && par[5]/par[0]<3))\n     cut1 = true;\n    return (cut0 && cut1);\n/*     return cut0;  */    \n}\n\n//-----------------------------------------\n// HitCut()\n//-----------------------------------------\nbool BluetMCPAnodeMaster::HitCut(const BluetWavePara& par){\n    bool cut0 = false;\n    bool cut1 = false;\n    if((par.HitAmp>15. && par.HitAmp<=3000. && par.HitTau>0.06 && par.HitTau<0.4) || (par.HitAmp>3000. && par.HitTau>0.06 && par.HitTau<0.4) )\n    cut0 = true;\n/*     if((ppar.HitAmp>15. && par.HitAmp<=3000. && par[5]/par[0]>0.08 && par[5]/par[0]<2.)||(par[0]>3000 && par[5]/par[0]>0.04 && par[5]/par[0]<1.5)) \n    cut1 = true; */\n    cut1 = true;    \n    return (cut0 && cut1);\n}\n\n\n//-----------------------------------------\n// SetDrawHit()\n//-----------------------------------------\nvoid BluetMCPAnodeMaster::SetDrawHit(vector<int> *boardID, vector<int> *chipID, vector<int> *channelID, const vector<array<double,6>>& v_fitpar, bool drawOpt, bool printOpt)\n{\n    DrawOpt = drawOpt;  \n    ispark = 0;\n    // ----- reset ----- \n   \n    HitReset();\n\n    // ----- push hit ----- \n    for(int ihit=0; ihit<v_fitpar.size(); ++ihit){\n        auto fitpar = v_fitpar[ihit];\n        array<int,3> index{boardID->at(ihit), chipID->at(ihit), channelID->at(ihit)}; \n        HitProcess(index, fitpar);        \n    } // end of ihit loop\n\n    // ----- push Spark -----  \n    SparkProcess(printOpt);\n    // ----- fill event -----\n    if(!DrawOpt){\n        EndEvent();\n    }else{\n        canode->Update();\n    }\n}\n\n\n\n//-----------------------------------------\n// SetDrawHit2()\n//-----------------------------------------\nvoid BluetMCPAnodeMaster::SetDrawHit2(vector<int> *boardID, vector<int> *chipID, vector<int> *channelID, const vector<vector<array<double, 6>>>& fitpar, bool drawOpt, bool printOpt){\n    DrawOpt = drawOpt;\n\n    // ----- reset ----- \n    if(DrawOpt) {\n        canode->Clear();\n        canode->Divide(4, 4);   \n    }\n    multimap<double, st_data> map_fitpar{};\n\n    for (size_t i = 0; i < fitpar.size(); i++)\n    {\n        array<int,3> index{boardID->at(i), chipID->at(i), channelID->at(i)}; \n\n        for (auto content: fitpar[i])\n        {\n            st_data ss{};\n            ss.fitpar =  content;\n            ss.index = index;\n            auto t = content[1];\n            map_fitpar.emplace(t, ss);\n        }\n    }\n    bool flag{false};\n\n    for (const auto& ppara: map_fitpar)\n    {\n        auto tcurr = ppara.first;\n        auto index1 = ppara.second.index;\n        auto fitpar = ppara.second.fitpar;     \n\n        if (flag)\n        {\n            if (TMath::Abs(tcurr-inittime) <= timewindow)\n            {\n                HitProcess(index1, fitpar);\n            }else\n            {\n                SparkProcess(printOpt);\n                InitEvent(tcurr);\n                HitProcess(index1, fitpar);\n            }\n        }else\n        {\n            InitEvent(tcurr);\n            HitProcess(index1, fitpar);            \n            flag = true;\n        }\n    }\n\n/*     if (fEvent->Hits.size()>0)\n    {\n        SparkProcess(printOpt);\n    } */\n    \n\n    /*SparkProcess(printOpt);\n    if(!DrawOpt){\n        EndEvent();\n    }*/\n\n    // ----- draw ----- \n    if(DrawOpt){\n        canode->Update();\n    }\n\n}\n\n//-----------------------------------------\n// ReEvent()\n//-----------------------------------------\nvoid BluetMCPAnodeMaster::ReEvent(bool drawOpt, bool printOpt){\n    DrawOpt = drawOpt;\n    ispark = 0;\n\n    // ----- reset ----- \n    if(DrawOpt) {\n        for (const auto c : vec_canvas)\n        {\n            c->Clear(); \n            c->Divide(4,4);\n        }\n        canode->Clear();\n        ht0tot->Reset();\n    } \n/*     cout << ispark << \"\\t\" << \"test7\\n\" << endl;     */            \n\n    // ---- Divided by time ---- \n    bool flag{false};    \n    for (const auto& ppara: fWavehit->WavePara)\n    {\n        auto tcurr = ppara.HitT;\n        ht0tot->Fill(tcurr);\n        if (flag)\n        {\n            if (TMath::Abs(tcurr-inittime) <= timewindow)\n            {\n                HitProcess2(ppara);\n            }else\n            {\n/*                 cout << ispark << \"\\t\" << tcurr << endl;            */     \n                SparkProcess2(printOpt);\n                InitEvent2(tcurr);\n                HitProcess2(ppara);\n/*                 cout << ispark << \"\\t\" << tcurr <<\"\\n\" << endl;    */             \n            }\n        }else\n        {\n            InitEvent2(tcurr);\n            HitProcess2(ppara);         \n            flag = true;\n        }\n    }\n\n    if (HitParaX.size()>0&&HitParaY.size()>0)\n    {\n        SparkProcess2(printOpt);\n    }\n/*     cout << ispark << \"\\t\" << \"test7\\n\" << endl;        */         \n\n    // ----- draw ----- \n    if(DrawOpt){\n        canode->cd();\n        ht0tot->DrawCopy(\"\");\n        for (const auto c : vec_canvas)\n        {\n            c->Update(); \n        }\n        canode->Update();\n    }else\n    {\n        EndEvent();\n    }\n    \n}\n\n//-----------------------------------------\n// Drawpic()\n//-----------------------------------------\nint BluetMCPAnodeMaster::Drawpic(){\n    auto icanvas = (ispark-1)/8;\n    auto ipad = (ispark-1)%8;\n    if (icanvas>ncanvas-1)\n    {\n        return -1;\n    }\n    \n    vec_canvas[icanvas]->cd(ipad*2+1);\n    hanode1->DrawCopy(\"colz\");\n    vec_canvas[icanvas]->cd(ipad*2+2);\n    ht0->GetXaxis()->SetRange(max(ht0->FindFirstBinAbove() - 25,1), min(ht0->FindLastBinAbove() + 25, WaveLength*10)); \n    ht0->DrawCopy(\"\");    \n\n    return 1;\n}\n\n//-----------------------------------------\n// EndEvent()\n//-----------------------------------------\nvoid BluetMCPAnodeMaster::EndEvent(){\n    fEvent->EventCount = fWavehit->EventCount;\n    fEvent->TimeStamp = fWavehit->TimeStamp;\n    eventTree->Fill();\n    fEvent->Reset();\n}\n\n//-----------------------------------------\n// HitReset()\n//-----------------------------------------     \nvoid BluetMCPAnodeMaster::HitReset(){\n    // ----- reset ----- \n    ht0->Reset();   \n    HitposX.clear();\n    HitposY.clear();\n    HittimeX.clear();\n    HittimeY.clear();\n    HitampX.clear();\n    HitampY.clear();\n    fEvent->Reset();\n}\n\n//-----------------------------------------\n// HitReset2()\n//-----------------------------------------     \nvoid BluetMCPAnodeMaster::HitReset2(){\n    // ----- reset ----- \n    HitParaX.clear();\n    HitParaY.clear();    \n}\n\n//-----------------------------------------\n// InitEvent()\n//-----------------------------------------\nvoid BluetMCPAnodeMaster::InitEvent(double tcurr){\n    HitReset();       \n    inittime = tcurr;\n}\n\n//-----------------------------------------\n// InitEvent2()\n//-----------------------------------------\nvoid BluetMCPAnodeMaster::InitEvent2(double tcurr){\n    // ----- reset ----- \n    HitReset2();   \n    inittime = tcurr;    \n}\n\n\n//-----------------------------------------\n// HitProcess()\n//-----------------------------------------\nvoid BluetMCPAnodeMaster::HitProcess(const array<int, 3>& index, const array<double, 6>& fitpar){\n\n        auto stripID = map_to_strip(index[0], index[1], index[2]);\n        BluetHit fHit{};\n        if(stripID<NstripX) {\n            if(HitCut(fitpar)){\n                HitposX.emplace_back((stripID+0.5)*Pitch);\n                HitampX.emplace_back(fitpar[0]);\n                HittimeX.emplace_back(fitpar[1]);\n            }\n            fHit.HitAmp = fitpar[0];\n            fHit.HitT = fitpar[1];\n            fHit.HitTau = fitpar[2];\n            fHit.HitBaseline = fitpar[3];\n            fHit.HitChi2 = fitpar[4];\n            fHit.HitPeakVal = fitpar[5];\n            fHit.HitPos = (stripID+0.5)*Pitch;\n            fHit.HitBoardID = index[0]; \n            fHit.HitChipID = index[1]; \n            fHit.HitChannelID = index[2]; \n            if(DrawOpt){\n                cout<<\"Xstrip >>> DAQ-ID: \"<<fHit.HitBoardID<<\"-\"<<fHit.HitChipID<<\"-\"<<fHit.HitChannelID\n                            <<\", stripID = \"<<stripID<<\", xpos = \"<<(stripID+0.5)*Pitch<<endl;\n                for(int ibin=0; ibin<NstripY; ibin++) {\n                    hanode1->Fill((stripID+0.5)*Pitch, (ibin+0.5)*Pitch, fitpar[0]); \n                }          \n            }\n                ht0->Fill(fitpar[1]);                \n        }\n        \n        if(stripID>=NstripX) {\n            if(HitCut(fitpar)){\n                HitposY.emplace_back((stripID-NstripX+0.5)*Pitch);\n                HitampY.emplace_back(fitpar[0]);\n                HittimeY.emplace_back(fitpar[1]);\n            }\n            fHit.HitAmp = fitpar[0];\n            fHit.HitT = fitpar[1];\n            fHit.HitTau = fitpar[2];\n            fHit.HitBaseline = fitpar[3];\n            fHit.HitChi2 = fitpar[4];\n            fHit.HitPeakVal = fitpar[5];\n            fHit.HitPos = (stripID+0.5)*Pitch;\n            fHit.HitTypeName = \"StripY\";\n            fHit.HitBoardID = index[0]; \n            fHit.HitChipID = index[1]; \n            fHit.HitChannelID = index[2]; \n            if(DrawOpt){\n                cout<<\"Ystrip >>> DAQ-ID: \"<<fHit.HitBoardID<<\"-\"<<fHit.HitChipID<<\"-\"<<fHit.HitChannelID\n                <<\", stripID = \"<<stripID<<\", ypos = \"<<(stripID-NstripX+0.5)*Pitch<<endl;\n                for(int ibin=0; ibin<NstripX; ibin++) {\n/*                     hanode0->Fill(ibin, stripID-NstripX, fitpar[0]); */\n                    hanode1->Fill((ibin+0.5)*Pitch, (stripID-NstripX+0.5)*Pitch, fitpar[0]);    \n                }\n            }\n                ht0->Fill(fitpar[1]);\n        }\n/*         fEvent->Hits.emplace_back(fHit); */\n\n}\n\n//-----------------------------------------\n// HitProcess2()\n//-----------------------------------------\n\nvoid BluetMCPAnodeMaster::HitProcess2(const BluetWavePara& par){\n    \n    if(HitCut(par) == false) return;\n    auto stripID = par.HitStripID;\n    wavepara_data w_d{};\n    if(stripID<NstripX) {\n        w_d.HitPos = (stripID+0.5)*Pitch;\n        w_d.HitAmp = par.HitAmp;\n        w_d.HitTime = par.HitTime;\n        w_d.HitT = par.HitT;\n        HitParaX.emplace_back(w_d);\n    }\n\n    if(stripID>=NstripX) {\n        w_d.HitPos = (stripID-NstripX+0.5)*Pitch;\n        w_d.HitAmp = par.HitAmp;\n        w_d.HitTime = par.HitTime;\n        w_d.HitT = par.HitT;        \n        HitParaY.emplace_back(w_d);\n    }\n\n}\n\n//-----------------------------------------\n// SparkProcess()\n//-----------------------------------------\nint BluetMCPAnodeMaster::SparkProcess(bool printOpt){\n   \n    if( HitposX.size()==0 || HitposY.size()==0 ) \n    return -1;\n    ispark++;\n    if (DrawOpt)\n    {\n        Drawpic();\n    }\n \n    BluetSpark fSpark;\n    fSpark.Nhits = HitposX.size() + HitposY.size();\n    fSpark.NhitsX = HitposX.size();\n    fSpark.NhitsY = HitposY.size();\n    fSpark.TminX = *min_element(HittimeX.begin(), HittimeX.end());\n    fSpark.TminY = *min_element(HittimeY.begin(), HittimeY.end());\n    fSpark.TmaxX = *max_element(HittimeX.begin(), HittimeX.end());\n    fSpark.TmaxY = *max_element(HittimeY.begin(), HittimeY.end());\n    auto minT = min(fSpark.TminX, fSpark.TminY);\n    fSpark.TOF0 = (double)TimeStamp*stampT - (double)WaveLength*sampleT + minT*sampleT;\n    \n    double sumEx = 0.;\n    double weightx = 0.;\n    //double posx = 0.;\n    for(int ix=0; ix<HitposX.size(); ++ix){\n        weightx = weightx + HitposX[ix]*HitampX[ix];\n        //posx = posx + HitposX[ix];\n        sumEx = sumEx + HitampX[ix];\n    }\n    \n    double sumEy = 0.;\n    double weighty = 0.;\n    //double posy = 0.;\n    for(int iy=0; iy<HitposY.size(); ++iy){\n        weighty = weighty + HitposY[iy]*HitampY[iy];\n        //posy = posy + HitposY[iy];\n        sumEy = sumEy + HitampY[iy];\n    }\n\n    if( sumEx!=0. && sumEy!=0.){\n        fSpark.CentroidPos[0] = weightx/sumEx;\n        fSpark.CentroidPos[1] = weighty/sumEy;\n    }\n    \n    fSpark.SparkSumE = sumEx + sumEy;\n    fSpark.SigmaT = ht0->GetStdDev();\n    fEvent->Sparks.emplace_back(fSpark);\n    if(printOpt){\n        cout<<\"\\nCentroidPos:  x = \"<<fSpark.CentroidPos[0]<<\" y = \"<<fSpark.CentroidPos[1]<<endl;\n        cout<<\"SparkSumE = \"<<fSpark.SparkSumE<<endl;\n        cout<<\"SigmaT = \"<<ht0->GetStdDev()<<endl;\n    }\n\n    if (DrawOpt)\n    {\n        hanode1->Reset();   \n        ht0->Reset();  \n    }\n    \n    return 1;\n\n}\n\n\nint BluetMCPAnodeMaster::SparkProcess2(bool printOpt){\n\n    if( HitParaX.size()==0 || HitParaY.size()==0 ) \n    return -1;\n\n    //sort by StripID/HitPos\n    sort(HitParaX.begin(), HitParaX.end(), comparewavedata);\n    sort(HitParaY.begin(), HitParaY.end(), comparewavedata);\n    \n    //Divide by StripID/HitPos\n    vector<vector<wavepara_data>> gHitParaX;\n    vector<vector<wavepara_data>> gHitParaY;\n    auto Pitch_ = Pitch;\n    auto divide_space = [Pitch_](vector<vector<wavepara_data>>& gHitPara, vector<wavepara_data>& HitPara){\n        vector<wavepara_data> tempHitPara;\n        tempHitPara.emplace_back(HitPara[0]);\n        for (size_t i = 0; i < HitPara.size() - 1; i++)\n        {\n            auto df = abs(HitPara[i+1].HitPos - HitPara[i].HitPos);\n            if (df <= 2*Pitch_)\n            {\n                tempHitPara.emplace_back(HitPara[i+1]);\n            }else\n            {\n                gHitPara.emplace_back(tempHitPara);\n                tempHitPara.clear();\n                tempHitPara.emplace_back(HitPara[i+1]);\n            }\n        }\n        if (!tempHitPara.empty()) {\n            gHitPara.emplace_back(tempHitPara);\n        }\n    };\n\n    divide_space(gHitParaX, HitParaX);\n    divide_space(gHitParaY, HitParaY);   \n\n\n    // rebuild by Goodness\n    auto nxevent = gHitParaX.size();\n    auto nyevent = gHitParaY.size();\n    auto nevent = min(nxevent, nyevent);\n    \n\n    vector<vector<double>> vGoodness(nxevent, vector<double>(nyevent));\n\n    for (size_t i = 0; i < gHitParaX.size(); i++)\n    {\n        for (size_t j = 0; j < gHitParaY.size(); j++)\n        {\n            vGoodness[i][j] = calculateGoodness(gHitParaX[i], gHitParaY[j]);\n        }\n    }\n\n    vector<std::array<int,2>> vMatchId{};\n    for (int ievent = 0; ievent < nevent; ievent++)\n    {\n        double minGoodness = std::numeric_limits<double>::max();\n        int minRow = 0, minCol = 0;            \n        for (int i = 0; i < nxevent; ++i) {\n            for (int j = 0; j < nyevent; ++j) {\n                if (vGoodness[i][j] < minGoodness) {\n                    minGoodness = vGoodness[i][j];\n                    minRow = i; \n                    minCol = j; \n                }\n            }\n        }\n        std::array<int,2> gid = {minRow,minCol};\n        vMatchId.emplace_back(gid);\n        // minrow and mincol set as max\n        for (size_t j = 0; j < nyevent; ++j) {\n            vGoodness[minRow][j] = std::numeric_limits<double>::max();\n        }\n\n        for (size_t i = 0; i < nxevent; ++i) {\n            vGoodness[i][minCol] = std::numeric_limits<double>::max();\n        }            \n    }\n\n    for (const auto & id: vMatchId)\n    {\n        ispark++;\n        BluetSpark fSpark;\n        \n        fSpark.NhitsX = gHitParaX[id[0]].size();\n        fSpark.NhitsY = gHitParaY[id[1]].size();    \n//        std::cout << gHitParaX[id[0]].size() << \"\\t\" << gHitParaY[id[1]].size()  << \"\\t\" << vMatchId.size()<< endl;\n        fSpark.Nhits = fSpark.NhitsX + fSpark.NhitsY;\n        fSpark.TminX = std::numeric_limits<double>::max();\n        fSpark.TmaxX = 0;  \n        fSpark.TminY = std::numeric_limits<double>::max();\n        fSpark.TmaxY = 0;\n        double sumEx = 0.;\n        double sumEy = 0.;\n        double weightx = 0.;\n        double weighty = 0.;\n        \n        for (const auto & temppara: gHitParaX[id[0]])\n        {\n            if (temppara.HitT < fSpark.TminX){\n                fSpark.TminX = temppara.HitT;\n            }\n            if (temppara.HitT > fSpark.TmaxX)\n            {\n                fSpark.TmaxX = temppara.HitT;\n            }\n            weightx = weightx + temppara.HitAmp*temppara.HitPos;\n            sumEx = sumEx + temppara.HitAmp;\n            hanodex->Fill(temppara.HitPos, temppara.HitAmp);\n            ht0->Fill(temppara.HitT);\n            \n            if (DrawOpt)\n            {\n                cout << \"Xstrip >>> xpos = \" << temppara.HitPos << endl;\n                for(int ibin=0; ibin<NstripX; ibin++) {\n                    hanode1->Fill(temppara.HitPos, (ibin+0.5)*Pitch, temppara.HitAmp); \n                }  \n            }\n        }\n        \n        for (const auto & temppara: gHitParaY[id[1]])\n        {\n            if (temppara.HitT < fSpark.TminY){\n                fSpark.TminY = temppara.HitT;\n            }\n            if (temppara.HitT > fSpark.TmaxY)\n            {\n                fSpark.TmaxY = temppara.HitT;\n            }\n            weighty = weighty + temppara.HitAmp*temppara.HitPos;\n            sumEy = sumEy + temppara.HitAmp;\n            hanodey->Fill(temppara.HitPos, temppara.HitAmp);\n            ht0->Fill(temppara.HitT);     \n            if (DrawOpt)\n            {\n                cout << \"Ystrip >>> ypos = \" << temppara.HitPos << endl;\n                for(int ibin=0; ibin<NstripY; ibin++) {\n                    hanode1->Fill((ibin+0.5)*Pitch, temppara.HitPos, temppara.HitAmp); \n                }  \n            }     \n        }\n        fSpark.CentroidPos[0] = weightx/sumEx;\n        fSpark.CentroidPos[1] = weighty/sumEy;\n\n        fSpark.SparkSumE = sumEx + sumEy;\n        fSpark.SigmaT = ht0->GetStdDev();\n        fSpark.SigmaX = hanodex->GetStdDev();\n        fSpark.SigmaY = hanodey->GetStdDev();\n        auto minT = min(fSpark.TminX, fSpark.TminY);\n        fSpark.TOF0 = (double)TimeStamp*stampT - (double)WaveLength*sampleT + minT*sampleT;\n\n        fEvent->Sparks.emplace_back(fSpark);\n        if(printOpt){\n            cout<<\"\\nCentroidPos:  x = \"<<fSpark.CentroidPos[0]<<\" y = \"<<fSpark.CentroidPos[1]<<endl;\n            cout<<\"SparkSumE = \"<<fSpark.SparkSumE<<endl;\n            cout<<\"T = \"<<minT<<endl;\n            cout<<\"<<<<<<<<<<<<<<<<<<<<<\"<<endl;\n/*             cout << Form(\"WaveLength = %d, TimeStamp = %d, sampleT = %f\", WaveLength, TimeStamp, sampleT) << endl;\n */        }\n\n    \n        if (DrawOpt)\n        {        \n            Drawpic();    \n            hanode1->Reset();   \n        }\n        hanodex->Reset();\n        hanodey->Reset();   \n        ht0->Reset();            \n    }\n    return 1;\n\n}\n\nvoid BluetMCPAnodeMaster::OutputPicture(){\n  if (Dir_Pic!=\"\")\n  {\n    for (size_t i = 0; i < ncanvas; i++)\n    {\n        vec_canvas[i]->SaveAs(Form(\"%s/c%d.png\", Dir_Pic.data(), i));\n    }\n    canode->SaveAs(Form(\"%s/Anode.png\", Dir_Pic.data()));\n  }else{\n    cout << \"Dir of picture was not found!!\" << endl; \n  }    \n}\n\n//-----------------------------------------\n// CompareWavedata()\n//-----------------------------------------\nbool BluetMCPAnodeMaster::comparewavedata(const wavepara_data& a, const wavepara_data& b){\n    return a.HitPos < b.HitPos;\n}\n\n//-----------------------------------------\n// calculateGoodness()\n//-----------------------------------------\ndouble BluetMCPAnodeMaster::calculateGoodness(const vector<wavepara_data>& vx, const vector<wavepara_data>& vy) {\n    array<double ,2> nhit = {vx.size(), vy.size()};\n    array<double ,2> sumAmp;\n    array<double ,2> sumT;\n    array<double ,2> avgt;\n    //array<double ,2> stddet;    \n    for (size_t i = 0; i < nhit[0]; i++)\n    {\n        sumAmp[0] = vx[i].HitAmp;\n        sumT[0] = vx[i].HitT;\n    }\n\n    for (size_t i = 0; i < nhit[1]; i++)\n    {\n        sumAmp[1] = vy[i].HitAmp;\n        sumT[1] = vy[i].HitT;\n    }  \n\n    for (size_t i = 0; i < 2; i++)\n    {\n        avgt[i] = sumT[i]/nhit[i];\n    }\n      \n    auto Goodness = (nhit[0]-nhit[1])*(nhit[0]-nhit[1]) + 0.5*(sumAmp[0] - sumAmp[1])*(sumAmp[0] - sumAmp[1]) + 0.2*(avgt[0] - avgt[1])*(avgt[0] - avgt[1]);\n    return Goodness;  // 反比关系\n}\n\n"}]],[".",[{"text":{"commandList":["<Esc>"],"actionKeys":[],"waitingForAnotherActionKey":false,"actionsRun":[{"name":"","isJump":false,"createsUndoPoint":false,"preservesDesiredColumn":false,"keysPressed":["i"],"actionType":"command","isCompleteAction":true,"runsOnceForEachCountPrefix":false,"modes":[0],"keys":[["i"],["<Insert>"]],"multicursorIndex":0},{"name":"","isJump":false,"createsUndoPoint":false,"preservesDesiredColumn":false,"keysPressed":["/","/"],"actionType":"command","isCompleteAction":true,"runsOnceForEachCountPrefix":false,"modes":[],"keys":[],"contentChanges":[{"text":"//","range":[{"line":123,"character":2},{"line":123,"character":2}],"rangeOffset":3285,"rangeLength":0}],"cursorStart":{"line":123,"character":2},"cursorEnd":{"line":112,"character":26}},{"name":"","isJump":false,"createsUndoPoint":false,"preservesDesiredColumn":false,"keysPressed":["<Esc>"],"actionType":"command","isCompleteAction":true,"runsOnceForEachCountPrefix":false,"modes":[1],"keys":[["<Esc>"],["<C-c>"],["<C-[>"]]}],"actionsRunPressedKeys":["i","/","/","<Esc>"],"bufferedKeys":[],"allowPotentialRemapOnFirstKey":true,"hasRunOperator":false,"isInsertion":true,"transformer":{"transformations":[]},"count":0,"operatorCount":0,"registerKey":"","registerName":"*"},"registerMode":0}]],[":",[{"text":{"commandList":["w"],"actionKeys":[],"waitingForAnotherActionKey":false,"actionsRun":[],"actionsRunPressedKeys":[],"bufferedKeys":[],"allowPotentialRemapOnFirstKey":true,"hasRunOperator":false,"isInsertion":false,"transformer":{"transformations":[]},"count":0,"operatorCount":0,"registerKey":"","registerName":":"},"registerMode":0}]],["-",[{"text":"  ~/works/wnri-bluet-v5/output/pic","registerMode":0}]],["1",[{"text":"  auto WaveTree = std::make_unique<TChain>(Treename);","registerMode":1}]]]}